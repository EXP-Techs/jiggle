package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/spf13/cobra"
)

// AST structs
type Field struct {
	Name string
	Type string
	Tag  int
}
type Message struct {
	Name   string
	Fields []Field
}
type RPC struct {
	Name       string
	InputType  string
	OutputType string
}
type Event struct {
	Name        string
	MessageType string
}
type Service struct {
	Name   string
	RPCs   []RPC
	Events []Event
}
type TrpcFile struct {
	Package  string
	Messages []Message
	Services []Service
}

// Parser
func parseTrpcFile(content string) (*TrpcFile, error) {
	trpc := &TrpcFile{}
	lines := strings.Split(content, "\n")
	pkgRegex := regexp.MustCompile(`^\s*package\s+([\w\.]+);`)
	msgRegex := regexp.MustCompile(`^\s*message\s+(\w+)\s*{`)
	svcRegex := regexp.MustCompile(`^\s*service\s+(\w+)\s*{`)
	rpcRegex := regexp.MustCompile(`^\s*rpc\s+(\w+)\s*\((\w+)\)\s+returns\s*\((\w+)\);`)
	evtRegex := regexp.MustCompile(`^\s*event\s+(\w+)\s*\((\w+)\);`)
	fldRegex := regexp.MustCompile(`^\s*(\w+)\s+(\w+)\s*=\s*(\d+);`)
	endBlockRegex := regexp.MustCompile(`^\s*}`)
	var currentMessage *Message
	var currentService *Service
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "//") {
			continue
		}
		if pkgMatch := pkgRegex.FindStringSubmatch(line); len(pkgMatch) > 1 {
			trpc.Package = pkgMatch[1]
		} else if msgMatch := msgRegex.FindStringSubmatch(line); len(msgMatch) > 1 {
			currentMessage = &Message{Name: msgMatch[1]}
		} else if svcMatch := svcRegex.FindStringSubmatch(line); len(svcMatch) > 1 {
			currentService = &Service{Name: svcMatch[1]}
		} else if rpcMatch := rpcRegex.FindStringSubmatch(line); len(rpcMatch) > 3 {
			if currentService != nil {
				rpc := RPC{Name: rpcMatch[1], InputType: rpcMatch[2], OutputType: rpcMatch[3]}
				currentService.RPCs = append(currentService.RPCs, rpc)
			}
		} else if evtMatch := evtRegex.FindStringSubmatch(line); len(evtMatch) > 2 {
			if currentService != nil {
				event := Event{Name: evtMatch[1], MessageType: evtMatch[2]}
				currentService.Events = append(currentService.Events, event)
			}
		} else if fldMatch := fldRegex.FindStringSubmatch(line); len(fldMatch) > 3 {
			if currentMessage != nil {
				field := Field{Type: fldMatch[1], Name: fldMatch[2]}
				currentMessage.Fields = append(currentMessage.Fields, field)
			}
		} else if endBlockRegex.MatchString(line) {
			if currentMessage != nil {
				trpc.Messages = append(trpc.Messages, *currentMessage)
				currentMessage = nil
			}
			if currentService != nil {
				trpc.Services = append(trpc.Services, *currentService)
				currentService = nil
			}
		}
	}
	return trpc, nil
}

// Go Type Mapper
func toGoType(trpcType string) string {
	switch trpcType {
	case "float64", "float32", "int32", "int64", "uint32", "uint64", "bool", "string":
		return trpcType
	case "bytes":
		return "[]byte"
	default:
		return "*" + trpcType
	}
}
func toGoFieldName(name string) string {
	parts := strings.Split(name, "_")
	for i := range parts {
		parts[i] = strings.Title(parts[i])
	}
	return strings.Join(parts, "")
}

// Code Generator
const codeTemplate = `// Code generated by trpc-gen-go. DO NOT EDIT.
// source: {{.FileName}}

package {{.PackageName}}

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	driver "github.com/exp-techs/jiggle/trpc-gen-go/driver"
)

// ========== Message Definitions ==========

{{range .TrpcFile.Messages}}
type {{.Name}} struct {
    {{- range .Fields}}
    {{.GoName}} {{.GoType}} ` + "`json:\"{{.JsonName}}\"`" + `
    {{- end}}
}
{{end}}

{{range .TrpcFile.Services}}
{{$svc := .}}
// ========== {{$svc.Name}} Service Client ==========

// {{$svc.Name}}Client is the client API for the {{$svc.Name}} service.
type {{$svc.Name}}Client interface {
    {{- range .RPCs}}
    {{.Name}}(ctx context.Context, in {{.GoInputType}}) ({{.GoOutputType}}, error)
    {{- end}}
    {{- range .Events}}
    Publish{{.Name}}(ctx context.Context, msg {{.GoMessageType}}) error
    {{- end}}
}

type {{$svc.LowerName}}Client struct {
	driver driver.ClientDriver
}

func New{{$svc.Name}}Client(drv driver.ClientDriver) {{$svc.Name}}Client {
	return &{{$svc.LowerName}}Client{driver: drv}
}

{{range .RPCs}}
func (c *{{$svc.LowerName}}Client) {{.Name}}(ctx context.Context, in {{.GoInputType}}) ({{.GoOutputType}}, error) {
	topic := "{{$.PackageName}}.{{$svc.Name}}.{{.Name}}"
	resp, err := c.driver.Request(topic, in, 5 * time.Second)
	if err != nil {
		return nil, err
	}
	var out {{.OutputType}}
	if err := json.Unmarshal(resp.Payload, &out); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response payload: %w", err)
	}
	return &out, nil
}
{{end}}

{{range .Events}}
func (c *{{$svc.LowerName}}Client) Publish{{.Name}}(ctx context.Context, msg {{.GoMessageType}}) error {
	topic := "{{$.PackageName}}.{{$svc.Name}}.{{.Name}}"
	return c.driver.Publish(topic, msg)
}
{{end}}

// ========== {{$svc.Name}} Service Server ==========

// {{$svc.Name}}Server is the server API for the {{$svc.Name}} service.
type {{$svc.Name}}Server interface {
    {{- range .RPCs}}
    {{.Name}}(context.Context, {{.GoInputType}}) ({{.GoOutputType}}, error)
    {{- end}}
    {{- range .Events}}
    Handle{{.Name}}(context.Context, {{.GoMessageType}}) error
    {{- end}}
}

func Register{{$svc.Name}}Server(drv driver.ClientDriver, srv {{$svc.Name}}Server) {
	{{- range .RPCs}}
	drv.Register("{{$.PackageName}}.{{$svc.Name}}.{{.Name}}", func(req driver.Message) (any, error) {
		var in {{.InputType}}
		if err := json.Unmarshal(req.Payload, &in); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request payload: %w", err)
		}
		return srv.{{.Name}}(context.Background(), &in)
	})
	{{- end}}
	{{- range .Events}}
	drv.Subscribe("{{$.PackageName}}.{{$svc.Name}}.{{.Name}}", "{{$svc.LowerName}}-{{.LowerName}}-group", func(msg driver.Message) error {
		var event {{.MessageType}}
		if err := json.Unmarshal(msg.Payload, &event); err != nil {
			return fmt.Errorf("failed to unmarshal event payload: %w", err)
		}
		return srv.Handle{{.Name}}(context.Background(), &event)
	})
	{{- end}}
}
{{end}}
`

func generateGoCode(trpc *TrpcFile, fileName, pkgName string) ([]byte, error) {
	type TemplateField struct {
		GoName, GoType, JsonName string
	}
	type TemplateMessage struct {
		Name   string
		Fields []TemplateField
	}
	type TemplateRPC struct {
		Name, InputType, OutputType, GoInputType, GoOutputType string
	}
	type TemplateEvent struct {
		Name, MessageType, GoMessageType, LowerName string
	}
	type TemplateService struct {
		Name, LowerName, PackageName string
		RPCs                         []TemplateRPC
		Events                       []TemplateEvent
	}
	type TemplateData struct {
		FileName    string
		PackageName string
		TrpcFile    struct {
			Messages []TemplateMessage
			Services []TemplateService
		}
	}

	data := TemplateData{FileName: fileName, PackageName: pkgName}
	for _, msg := range trpc.Messages {
		tMsg := TemplateMessage{Name: msg.Name}
		for _, fld := range msg.Fields {
			tFld := TemplateField{GoName: toGoFieldName(fld.Name), GoType: toGoType(fld.Type), JsonName: fld.Name}
			tMsg.Fields = append(tMsg.Fields, tFld)
		}
		data.TrpcFile.Messages = append(data.TrpcFile.Messages, tMsg)
	}
	for _, svc := range trpc.Services {
		tSvc := TemplateService{Name: svc.Name, LowerName: strings.ToLower(svc.Name), PackageName: pkgName}
		for _, rpc := range svc.RPCs {
			tRpc := TemplateRPC{Name: rpc.Name, InputType: rpc.InputType, OutputType: rpc.OutputType, GoInputType: toGoType(rpc.InputType), GoOutputType: toGoType(rpc.OutputType)}
			tSvc.RPCs = append(tSvc.RPCs, tRpc)
		}
		for _, evt := range svc.Events {
			tEvt := TemplateEvent{Name: evt.Name, MessageType: evt.MessageType, GoMessageType: toGoType(evt.MessageType), LowerName: strings.ToLower(evt.Name)}
			tSvc.Events = append(tSvc.Events, tEvt)
		}
		data.TrpcFile.Services = append(data.TrpcFile.Services, tSvc)
	}

	tmpl, err := template.New("trpc").Parse(codeTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %w\n---GENERATED CODE---\n%s", err, buf.String())
	}
	return formatted, nil
}

// Cobra CLI
var (
	inputFile string
	outputDir string
)
var rootCmd = &cobra.Command{Use: "trpc-gen-go"}
var generateCmd = &cobra.Command{
	Use:   "generate",
	Short: "Generate Go code from a .trpc file",
	Run: func(cmd *cobra.Command, args []string) {
		if inputFile == "" {
			log.Fatal("Input file path must be provided with --file")
		}
		if outputDir == "" {
			log.Fatal("Output directory must be provided with --out")
		}
		content, err := ioutil.ReadFile(inputFile)
		if err != nil {
			log.Fatalf("Failed to read input file %s: %v", inputFile, err)
		}
		trpcAST, err := parseTrpcFile(string(content))
		if err != nil {
			log.Fatalf("Failed to parse .trpc file: %v", err)
		}
		pkgName := trpcAST.Package
		if pkgName == "" {
			pkgName = filepath.Base(outputDir)
		}
		goPkgName := strings.ReplaceAll(pkgName, ".", "_")
		generatedCode, err := generateGoCode(trpcAST, filepath.Base(inputFile), goPkgName)
		if err != nil {
			log.Fatalf("Failed to generate Go code: %v", err)
		}
		baseName := strings.TrimSuffix(filepath.Base(inputFile), ".trpc")
		outputFileName := filepath.Join(outputDir, baseName+".trpc.go")
		err = os.MkdirAll(outputDir, 0755)
		if err != nil {
			log.Fatalf("Failed to create output directory %s: %v", outputDir, err)
		}
		err = ioutil.WriteFile(outputFileName, generatedCode, 0644)
		if err != nil {
			log.Fatalf("Failed to write output file %s: %v", outputFileName, err)
		}
		fmt.Printf("Successfully generated %s\n", outputFileName)
	},
}

func init() {
	rootCmd.AddCommand(generateCmd)
	generateCmd.Flags().StringVarP(&inputFile, "file", "f", "", "Path to the input .trpc file (required)")
	generateCmd.Flags().StringVarP(&outputDir, "out", "o", "", "Path to the output directory (required)")
}
func main() {
	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}
