// main.go
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/spf13/cobra"
)

// AST (Abstract Syntax Tree) structs to hold the parsed .trpc file data.
// These structs represent the logical structure of your protocol definition.

type Field struct {
	Name string
	Type string
	Tag  int
}

type Message struct {
	Name   string
	Fields []Field
}

type RPC struct {
	Name       string
	InputType  string
	OutputType string
}

type Event struct {
	Name        string
	MessageType string
}

type Service struct {
	Name   string
	RPCs   []RPC
	Events []Event
}

type TrpcFile struct {
	Package  string
	Messages []Message
	Services []Service
}

// --- Parser ---
// A simple line-by-line parser. A real-world implementation would use a more
// robust lexer/parser, but this is sufficient for a PoC.

func parseTrpcFile(content string) (*TrpcFile, error) {
	trpc := &TrpcFile{}
	lines := strings.Split(content, "\n")

	// Regex to capture different parts of the .trpc syntax
	pkgRegex := regexp.MustCompile(`^\s*package\s+([\w\.]+);`)
	msgRegex := regexp.MustCompile(`^\s*message\s+(\w+)\s*{`)
	svcRegex := regexp.MustCompile(`^\s*service\s+(\w+)\s*{`)
	rpcRegex := regexp.MustCompile(`^\s*rpc\s+(\w+)\s*\((\w+)\)\s+returns\s*\((\w+)\);`)
	evtRegex := regexp.MustCompile(`^\s*event\s+(\w+)\s*\((\w+)\);`)
	fldRegex := regexp.MustCompile(`^\s*(\w+)\s+(\w+)\s*=\s*(\d+);`)
	endBlockRegex := regexp.MustCompile(`^\s*}`)

	var currentMessage *Message
	var currentService *Service

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "//") {
			continue
		}

		if pkgMatch := pkgRegex.FindStringSubmatch(line); len(pkgMatch) > 1 {
			trpc.Package = pkgMatch[1]
		} else if msgMatch := msgRegex.FindStringSubmatch(line); len(msgMatch) > 1 {
			currentMessage = &Message{Name: msgMatch[1]}
		} else if svcMatch := svcRegex.FindStringSubmatch(line); len(svcMatch) > 1 {
			currentService = &Service{Name: svcMatch[1]}
		} else if rpcMatch := rpcRegex.FindStringSubmatch(line); len(rpcMatch) > 3 {
			if currentService != nil {
				rpc := RPC{Name: rpcMatch[1], InputType: rpcMatch[2], OutputType: rpcMatch[3]}
				currentService.RPCs = append(currentService.RPCs, rpc)
			}
		} else if evtMatch := evtRegex.FindStringSubmatch(line); len(evtMatch) > 2 {
			if currentService != nil {
				event := Event{Name: evtMatch[1], MessageType: evtMatch[2]}
				currentService.Events = append(currentService.Events, event)
			}
		} else if fldMatch := fldRegex.FindStringSubmatch(line); len(fldMatch) > 3 {
			if currentMessage != nil {
				// Note: For simplicity, we don't parse the tag number here, but a full
				// implementation would.
				field := Field{Type: fldMatch[1], Name: fldMatch[2]}
				currentMessage.Fields = append(currentMessage.Fields, field)
			}
		} else if endBlockRegex.MatchString(line) {
			if currentMessage != nil {
				trpc.Messages = append(trpc.Messages, *currentMessage)
				currentMessage = nil
			}
			if currentService != nil {
				trpc.Services = append(trpc.Services, *currentService)
				currentService = nil
			}
		}
	}

	return trpc, nil
}

// --- Go Type Mapper ---
// Maps .trpc types to Go types.

func toGoType(trpcType string) string {
	// This is a simplified mapping based on your spec.
	// It assumes that message types are defined in the same package.
	switch trpcType {
	case "float64", "float32", "int32", "int64", "uint32", "uint64", "bool", "string":
		return trpcType
	case "bytes":
		return "[]byte"
	default:
		// Assumes it's a custom message type
		return "*" + trpcType
	}
}

func toGoFieldName(name string) string {
	// Converts snake_case to CamelCase for Go struct fields
	parts := strings.Split(name, "_")
	for i := range parts {
		parts[i] = strings.Title(parts[i])
	}
	return strings.Join(parts, "")
}

// --- Code Generator ---

const codeTemplate = `// Code generated by trpc-gen-go. DO NOT EDIT.
// source: {{.FileName}}

package {{.PackageName}}

import "context"

// ========== Message Definitions ==========

{{range .TrpcFile.Messages}}
type {{.Name}} struct {
    {{- range .Fields}}
    {{.GoName}} {{.GoType}} ` + "`json:\"{{.JsonName}}\"`" + `
    {{- end}}
}
{{end}}

// ========== Service Definitions ==========
{{range .TrpcFile.Services}}

// {{.Name}}Server is the server API for the {{.Name}} service.
type {{.Name}}Server interface {
    {{- range .RPCs}}
    {{.Name}}(context.Context, {{.GoInputType}}) ({{.GoOutputType}}, error)
    {{- end}}
    {{- range .Events}}
    // Handle{{.Name}} handles the asynchronous {{.Name}} event.
    Handle{{.Name}}(context.Context, {{.GoMessageType}}) error
    {{- end}}
}


// {{.Name}}Client is the client API for the {{.Name}} service.
type {{.Name}}Client interface {
    {{- range .RPCs}}
    // {{.Name}} performs a synchronous RPC call.
    {{.Name}}(ctx context.Context, in {{.GoInputType}}) ({{.GoOutputType}}, error)
    {{- end}}
    {{- range .Events}}
    // Publish{{.Name}} publishes the asynchronous {{.Name}} event.
    Publish{{.Name}}(ctx context.Context, msg {{.GoMessageType}}) error
    {{- end}}
}

{{end}}
`

func generateGoCode(trpc *TrpcFile, fileName, pkgName string) ([]byte, error) {
	// Prepare data for the template
	type TemplateField struct {
		GoName   string
		GoType   string
		JsonName string
	}
	type TemplateMessage struct {
		Name   string
		Fields []TemplateField
	}
	type TemplateRPC struct {
		Name         string
		GoInputType  string
		GoOutputType string
	}
	type TemplateEvent struct {
		Name          string
		GoMessageType string
	}
	type TemplateService struct {
		Name   string
		RPCs   []TemplateRPC
		Events []TemplateEvent
	}
	type TemplateTrpcFile struct {
		Messages []TemplateMessage
		Services []TemplateService
	}
	type TemplateData struct {
		FileName    string
		PackageName string
		TrpcFile    TemplateTrpcFile
	}

	data := TemplateData{
		FileName:    fileName,
		PackageName: pkgName,
	}

	for _, msg := range trpc.Messages {
		tMsg := TemplateMessage{Name: msg.Name}
		for _, fld := range msg.Fields {
			tFld := TemplateField{
				GoName:   toGoFieldName(fld.Name),
				GoType:   toGoType(fld.Type),
				JsonName: fld.Name,
			}
			tMsg.Fields = append(tMsg.Fields, tFld)
		}
		data.TrpcFile.Messages = append(data.TrpcFile.Messages, tMsg)
	}

	for _, svc := range trpc.Services {
		tSvc := TemplateService{Name: svc.Name}
		for _, rpc := range svc.RPCs {
			tRpc := TemplateRPC{
				Name:         rpc.Name,
				GoInputType:  toGoType(rpc.InputType),
				GoOutputType: toGoType(rpc.OutputType),
			}
			tSvc.RPCs = append(tSvc.RPCs, tRpc)
		}
		for _, evt := range svc.Events {
			tEvt := TemplateEvent{
				Name:          evt.Name,
				GoMessageType: toGoType(evt.MessageType),
			}
			tSvc.Events = append(tSvc.Events, tEvt)
		}
		data.TrpcFile.Services = append(data.TrpcFile.Services, tSvc)
	}

	// Execute the template
	tmpl, err := template.New("trpc").Parse(codeTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Provide more context on formatting errors
		return nil, fmt.Errorf("failed to format generated code: %w\n---GENERATED CODE---\n%s", err, buf.String())
	}

	return formatted, nil
}

// --- Cobra CLI Commands ---

var (
	inputFile string
	outputDir string
)

var rootCmd = &cobra.Command{
	Use:   "trpc-gen-go",
	Short: "A code generator for the TRPC protocol",
	Long:  `trpc-gen-go is a CLI tool that parses .trpc files and generates Go code for clients and servers.`,
}

var generateCmd = &cobra.Command{
	Use:   "generate",
	Short: "Generate Go code from a .trpc file",
	Run: func(cmd *cobra.Command, args []string) {
		if inputFile == "" {
			log.Fatal("Input file path must be provided with --file")
		}
		if outputDir == "" {
			log.Fatal("Output directory must be provided with --out")
		}

		// 1. Read the input file
		content, err := ioutil.ReadFile(inputFile)
		if err != nil {
			log.Fatalf("Failed to read input file %s: %v", inputFile, err)
		}

		// 2. Parse the file content
		trpcAST, err := parseTrpcFile(string(content))
		if err != nil {
			log.Fatalf("Failed to parse .trpc file: %v", err)
		}

		// Use the package name from the file, or default to the output dir name
		pkgName := trpcAST.Package
		if pkgName == "" {
			pkgName = filepath.Base(outputDir)
		}

		// **FIX**: Sanitize the package name for Go by replacing dots with underscores.
		goPkgName := strings.ReplaceAll(pkgName, ".", "_")

		// 3. Generate the Go code
		generatedCode, err := generateGoCode(trpcAST, filepath.Base(inputFile), goPkgName)
		if err != nil {
			log.Fatalf("Failed to generate Go code: %v", err)
		}

		// 4. Write the output file
		baseName := strings.TrimSuffix(filepath.Base(inputFile), ".trpc")
		outputFileName := filepath.Join(outputDir, baseName+".trpc.go")

		err = os.MkdirAll(outputDir, 0755)
		if err != nil {
			log.Fatalf("Failed to create output directory %s: %v", outputDir, err)
		}

		err = ioutil.WriteFile(outputFileName, generatedCode, 0644)
		if err != nil {
			log.Fatalf("Failed to write output file %s: %v", err)
		}

		fmt.Printf("Successfully generated %s\n", outputFileName)
	},
}

func init() {
	rootCmd.AddCommand(generateCmd)
	generateCmd.Flags().StringVarP(&inputFile, "file", "f", "", "Path to the input .trpc file (required)")
	generateCmd.Flags().StringVarP(&outputDir, "out", "o", "", "Path to the output directory (required)")
}

func main() {
	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}
